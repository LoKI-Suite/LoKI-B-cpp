\documentclass{article}

\usepackage{framed}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{siunitx}
% the next block is the modern way of achieving 'a4wide'
\usepackage{geometry}
\usepackage{layout}
\geometry{
  includeheadfoot,
  margin=2.54cm
}
\usepackage{xfrac}
\newcommand{\frachalf}{\ensuremath{\sfrac{1}{2}}}
\newcommand{\phalf}[1]{\ensuremath{{#1}+\frachalf}}
\newcommand{\mhalf}[1]{\ensuremath{{#1}-\frachalf}}

\newcommand{\MEAN}[1]{\ensuremath{\langle{{#1}}\rangle}}

\input{../../doc/listings}
\input{../../doc/loki_defs}

% boldface matrix and vector
\newcommand{\bmat}[1]{{\ensuremath{\bm {#1}}}}
\newcommand{\bvec}[1]{{\ensuremath{\bm {#1}}}}
% diag - make a diagonal matrix from a vector.
\DeclareMathOperator{\diag}{diag}


\bibliographystyle{unsrt}

\title{Notes on the C++ Implementation of LoKI-B}
\author{Jan van Dijk, Daan Boer and Wouter Graef}

\begin{document}

\maketitle

\abstract{
This document contains notes about the C++ version of LoKI-B.
It provides additional details of definitions and algorithms that are not
explicitly written in the LoKI-B paper \cite{Tejero2019} or the User Manual
of the initial public release of LoKI-B \cite{Manual_1_0_0}. It also
discusses features of the C++ version that are not available yet in the MATLAB
version, such as support for JSON input files and the Web deployment of LoKI-B
and discusses and motivates things that have been done different in the C++
version for various reasons.
}

\tableofcontents

\section{Definitions}

\subsection{Basic Quantities}

There are multiple variables that describe the densities (absolute and relative)
of the gases and states.
\begin{itemize}
  \item $N$
  \item $N_k$
  \item Gas fraction:
  \begin{equation}
    \chi_k = N_k/N.
    \label{eq:chi_k}
  \end{equation}
  \item $\xi_{k_i}$
  \item $\delta_{k_i}$
\end{itemize}

\begin{itemize}
  \item In the Loki-B paper \cite{Tejero2019}, in the text between equations 1
  and 2, $\xi_{k_i}$ is defined as the density of a state $k_i$ divided by that
  of the sum of all densities of states of gas $k$. On the other hand, in the
  LoKI-B user manual (version 1.0.0) \cite{Manual_1_0_0} below equation 2 it
  is defined as the density of that state divided by its parent density.
  TODO: what is in MATLAB? Let's adopt that and state that clearly here.
  \item The name \SRC{density} that appeared in the code corresponded to the
  `reduced density' $\delta_{k}$ in the user guide. In the C++ code this is
  now provided by member \SRC{delta()} of the state class.
\end{itemize}

\subsection{The gamma constant}

\label{sec:gamma-constant}

Gamma has been introduced. This constant also appears in the BOLSIG+ paper
\cite{Hagelaar2005}, where it introduced just below equation 6, and is defined
as
\begin{equation}
  \gamma = \sqrt{2e/m_e}.
  \label{eq:gamma}
\end{equation}
The symbol is available as \SRC{SI::gamma} (relative to the \SRC{loki}
namespace). Note that this appears {\em many} times in the code, and
this change has resulted in much better readability.

Note that in LoKI-B documentation the symbol $\gamma_k$ is
defined as the mass ration of the electron and a species $k$
\cite[below eqn. 9d]{Manual_1_0_0},
\begin{equation}
  \gamma_k = m_e/m_k,
\end{equation}
but the presence of the subscript $k$ avoids any confusion with the
constant $\gamma$, which in addition has the \SRC{SI::} prefix.

\subsection{The functions $G_x(y)$ and $g_x(u)$}
\label{sec:G_x,g_x}


Many terms on the left-hand side of the 2-term approximation of the Boltzmann
equation are written in terms of energy-derivatives of functions $G_x(u)$, where
$x$ denotes a particular process type.
\begin{itemize}
  \item Expressions for $G_x(u)$ are given in equations 6b-c of the LoKI-B paper
        \cite{Tejero2019} and in equations 9b-c of the manual \cite{Manual_1_0_0};
        those are identical.
\end{itemize}
Of course, the Boltzmann equation does not change if each term is divided by the
same non-zero constant value. That does, however, change the meaning/interpretation
of the individual terms and has resulted in conflicting definitions for
auxiary functions $g_x(u)$.
\begin{itemize}
  \item In the paper \cite[eqn. 15d]{Tejero2019}, $g_x(u)$ and $c_u$ are defined
        by the relation
        \[
          G_x(u) = g_x(u)\left(f(u)+c_x\DERIV{f(u)}{u}\right),
        \]
        of which the energy-derivative is stated in the text. As an example,
        for the elastic operator this results in \cite[eqn. 6b]{Tejero2019},
        \[
           g_{el}(u)=-\sum\limits_k 2\gamma_k\nu^{el}_{k,c}(u)u^{3/2}
           = -N\sqrt{2e/m_e}\;2u^2\sum\limits_k \delta_k\gamma_k\sigma^{el}_{k,c}(u)
           := -N\gamma\;2u^2\sigma^{el}_u(u).
        \]
        (TODO: add note about the 'eneragy averaged cross section here, including $2m_e/m_k$.)
        This matches the {\em comments} in the MATLAB code, which announce
\begin{lstlisting}
  g_c(u) = -N*sqrt(2*e/me)*2*u^2*sigmaC(u);
\end{lstlisting}
  \item In the user manual \cite[eqn. 16d]{Tejero2019}, $g_x(u)$ is defined
        relative to $G_x(u)/(N\gamma)$, that is:
        \begin{equation}
          \frac{1}{N\gamma}G_x(u) = g_x(u)\left(f(u)+c_x\DERIV{f(u)}{u}\right).
          \label{eq:G(g)}
        \end{equation}
        That would instead result in:
\begin{lstlisting}
  g_c(u) = -2*u^2*sigmaC(u);
\end{lstlisting}
  \item In the actual implementation we find the latter definition, but {\em without
        the minus sign}: the implementation of the elastic operator actually does
\begin{lstlisting}
  boltzmann.g_c = 2*boltzmann.energyGrid.node.^2.*boltzmann.elasticCrossSection;
\end{lstlisting}
        So the function $g_x(u)$ that we actually find in the code corresponds to the definition
        \[
          \frac{1}{N\gamma}G_x(u) = -g_x(u)\left(f(u)+c_x\DERIV{f(u)}{u}\right).
        \]
  \item Since the expressions for the discretization coefficients in terms of
        $g_x(u)$ are the same in the code as in the manual, the effect is that
        the matrices $M^x$ that are set up such that
        \[
           [M^x_{ij}][f_j] \doteq -\frac{1}{N\gamma}\DERIV{G_x(u)}{u}.
        \]
        (Also see section \ref{sec:discretization}.)
  \item Note that the elements of $g_x(u)$ are also used to calculated the
        elastic terms on the power balance, see \cite[eq. 24c]{Tejero2019},
        \cite[eq. 38c]{Manual_1_0_0} and section \ref{sec:power-terms} of the
	present text\footnote{
          In the code, a different expression is used, that appears to be
          based on partial integration of the expressions in the paper and
          manual. See section \ref{sec:power-terms}.}
        When the meaning of $g_x(u)$ is changed, also those expressions must
        be updated accordingly.
  \item In order to compare expressions with those in the BOLSIG+ paper
        \cite{Hagelaar2005}, it is important to realize that in that paper the
        terms of the equation correspond to the LoKI-B expressions
        \[
          \frac{1}{N}\DERIV{G_x(u)}{u},
        \]
        in other words: there is no division by $\gamma$. As an example, consider
        \[
          \frac{1}{N}G_{el}(u)
          = -\gamma\;2u^2\sigma^{el}_u(u)\left[f(u) + \frac{k_BT}{e}\DERIV{f(u)}{u}\right].
        \]
        This corresponds to the elastic part (involving $\sigma_\epsilon$) of equations
        40 and 41 of \cite{Hagelaar2005}.
        TODO: note the definition of $\sigma_\epsilon$ in equation (42) in
        \cite{Hagelaar2005}. The correspondence with the expression in LoKI-B should
        be made explicit, the mass-ratios emphasized.
\end{itemize}

\subsection{The CAR Implementation}

The CAR term in the EBE is described by equation 6c of \cite{Tejero2019}.
It can be written in the form \eqref{eq:G(g)}, with
\begin{align}
  N\gamma g_{CAR} &= -\sum\limits_k 4B_k\nu_{0,k}\sqrt{u}, \\
  c_{CAR} &= k_BT_e/e.
\end{align}
The frequency of the CAR cross section for a gas $k$ is presented just below
equation 6d of \cite{Tejero2019}. Using the definition of the gas fraction
$\chi_k$ from equation \eqref{eq:gamma} this becomes
\begin{equation}
  \nu_{0,k} = N_k\sqrt{2eu/m_e}\sigma_{0,k} = N\gamma\sqrt{u}\chi_k\sigma_{0,k}
\end{equation}
and substitution in the expression for $g_{CAR}$ yields
\begin{equation}
  g_{CAR} = -4u\sum\limits_k \chi_k\sigma_{0,k}B_k.
  \label{eq:g_CAR}
\end{equation}
\begin{framed}
  As discussed elsewhere, in the code we find $g_{CAR}$ defined without
  the minus sign --- the same is true for other $g_x(u)$.
\end{framed}

The CAR cross section for a gas $k$ can be found in the LoKI-B paper \cite{Tejero2019}
in the text below equation 6d, which states
\begin{equation}
  \sigma_{0,k} = \frac{8\pi}{15}Q_{k,au}^2a_0^2,
  \label{eq:sigma_CAR}
\end{equation}
where $a_0$ is the Bohr radius and $Q_{k,au}$ is the quadrupole moment of that
gas {\em in atomic units} ($ea_0^2$).
This expression is also found in the user manual \cite{Manual_1_0_0} (below
equation 9d) and in the paper of Ridenti \etal \cite{Ridenti2015} (below
equation 8b). Those sources refer to the paper of Gerjuoy and Stein
\cite{Gerjuoy1955}, where this term appears as a factor in equation 20.
To emphasize that $Q_{k,au}$ is a dimensionless number (the numerical value
that arises when atomic units are used), we have added the suffix $au$ in equation
\eqref{eq:sigma_CAR}; this does not appear in the sources cited above.

Substitution of this expression in \eqref{eq:g_CAR} gives
\begin{equation}
  g_{CAR} = -4u\frac{8\pi}{15}a_0^2\sum\limits_k \chi_k Q_{k,au}^2B_k.
\end{equation}

\begin{framed}
Note (December 14 2020) ---
In version 1.0.0 of the LoKI-B code (MATLAB), $\sigma_{0,k} = \frac{8\pi}{15}Q_{k,au}a_0^2$,
was used (without the square on $Q_{k,au}$). Since $Q_{k,au}=Q_k/(ea_0^2)$, where
$Q_k$ is the value in SI units, that would result in $\sigma_{0,k}=(8\pi/15)Q_k/e$
and in
\begin{equation}
  \sum\limits_k\chi_k\sigma_{0,k}B_k = \frac{8\pi}{15}\frac{1}{e}\sum\limits_k \chi_k Q_kB_k,
\end{equation}
and this is what was found in the code in \SRC{Boltzmann.m} line 423,
in function \SRC{evaluateCAROperator}:
\begin{lstlisting}[language=matlab]
sigma0B = 0;
for gasName = boltzmann.CARgases
  gasID = Gas.find(gasName, boltzmann.gasArray);
  gas = boltzmann.gasArray(gasID);
  sigma0B = sigma0B + gas.fraction*gas.electricQuadrupoleMoment*gas.rotationalConstant;
end
sigma0B = 8.0*pi*sigma0B/(15.0*Constant.electronCharge);
\end{lstlisting}
(Note that in the MATLAB code indeed \SRC{electricQuadrupoleMoment} is expressed
in SI units, see file \SRC{input/Databases/quadrupoleMoment.txt}.)

Since $Q_{k,au}$ is usually of order unity, it is no surprise
that this could go unnoticed. The implementation has been corrected to
\begin{lstlisting}[language=matlab]
a02 = Constant.bohrRadius*Constant.bohrRadius:
sigma0B = 0;
for gasName = boltzmann.CARgases
  gasID = Gas.find(gasName, boltzmann.gasArray);
  gas = boltzmann.gasArray(gasID);
  Qau = gas.electricQuadrupoleMoment/(Constant.electronCharge*a02);
  sigma0B = sigma0B + gas.fraction*Qau*Qau*gas.rotationalConstant;
end
sigma0B = (8.0*pi*a02/15.0)*sigma0B;
\end{lstlisting}
Previous versions of the C++ implementation had the same problem, it
has been fixed along the same lines.

\end{framed}

\subsection{The Electron-Electron Collision Operator}

The electron-electron operator is defined by a flux function $G_{ee}(u)$ \cite[eqn. 6d]{Tejero2019},
which is given by
\begin{equation}
	G_{ee}(u) = -2\nu_{ee}u^{3/2}\left[I(u)f(u) + J(u)\DERIV{f}{u}\right];
\end{equation}
in the text below that equation, the electron-electron collision frequency is given as
\begin{align}
	\nu_{ee} &= 4\pi\left(\frac{e^2}{4\pi\epsilon_0 m_e}\right)^2\frac{\ln\Lambda_c}{v^3}n_e, \\
	\Lambda_c &= 12\pi\lambda_D^3n_e,
\end{align}
where $\lambda_D$ is the Debye length. We assume that the usual expression for electrons
with ion shielding is assumed, in which case (NOTE: with $T^{si}_e$ in SI units $\si{K}$
and $T_e$ the expression in electron-volt, used in LoKI-B)
\begin{equation}
	\lambda_D
	= \sqrt{\frac{\epsilon_0kT^{si}_e}{n_e e^2}}
	= \sqrt{\frac{\epsilon_0(kT^{si}_e/e)}{n_e e}}
	= \sqrt{\frac{\epsilon_0T_e}{n_e e}}
\end{equation}
The `Spitzer integrals' $I(u)$ and $J(u)$ are not spelled out; references
to \cite{Allis1956} and to \cite{Ferreira2000} are provided for these expressions.
In \cite[eqns. 59--62]{Ferreira2000} we find:
\begin{align}
	I(u) &= \int\limits_0^u f(u')\sqrt{u'}\dd{u'}, \label{eq:I} \\
	J(u) &= \frac{2}{3}\left(
		\int\limits_0^u f(u')(u')^{3/2}\dd{u'}
		+
		u^{3/2}\int\limits_u^\infty f(u')\dd{u'}
		\right). \label{eq:J}
\end{align}
Tejero et al. \cite{Tejero2019} provide a reference to \cite{Shkarofsky1966}. Note that in the latter source
this material can be found around page 284, but that a speed-representation of the Boltzmann equation is used,
rather than an energy representation.

In the implementation of the Boltzmann equation in the LoKI-B code, the operator
appears as a term \cite[eqn. 38]{Manual_2_2_0}
\begin{equation}
	-\frac{1}{N\gamma}\DERIV{G_{ee}(u)}{u}
	=
	\DERIV{}{u}\left(\frac{2\nu_{ee}u^{3/2}}{N\gamma}\left[I(u)f(u) + J(u)\DERIV{f}{u}\right]\right)
	:=
	\DERIV{}{u}\left(g_{ee}\left[I(u)f(u) + J(u)\DERIV{f}{u}\right]\right),
	\label{eq:-1/NgammadGee/du}
\end{equation}
with \cite[eqn. 37a]{Manual_2_2_0}
\begin{equation}
	g_{ee}(u) = \frac{2\nu_{ee}u^{3/2}}{N\gamma}.
\end{equation}

Let us first take a look at this factor $g_{ee}(u)$. Using its definition and the relation $v=\gamma\sqrt{u}$, we find
\begin{equation}
	g_{ee}(u)
	= 8\pi\left(\frac{e^2}{4\pi\epsilon_0 m_e}\right)^2\frac{\ln\Lambda_c}{\gamma^4}\frac{n_e}{N}
	= 8\pi\left(\frac{e^2}{4\pi\epsilon_0 m_e}\right)^2\left(\ln\Lambda_c\right)\frac{m_e^2}{4e^2}\frac{n_e}{N}
	= \frac{e^2}{8\pi\epsilon_0^2}\frac{n_e}{N}\ln\Lambda_c.
\end{equation}
Observations:
\begin{itemize}
	\item In spite of the notation, $g_{ee}(u)$ does {\em not} depend on the energy $u$;
		it depends only on the degree of ionization $n_e/N$ and on the Debye length
		(which depends on the ratio $T_e/n_e$).
	\item NOTE that the definition of $g_{ee}(u)$ differs from that of the other
		$g_x(u)$, in the sense that it is {\em not} the coefficient of the advective
		part of $G(u)$ (in energy space) --- see section \ref{sec:G_x,g_x}.
		That coefficient is given by the product $g_{ee}(u)I(u)$.
	\item In equations \cite[39a--b]{Manual_2_2_0} the suggestion is made once more that
		$g_{ee}$ is energy-dependent. The fact that it is not allows this factor to
		be taken outside of the $u$-differentation and is used to derive the results
		for $A_n$ and $B_n$.
	\item In the documents (manual and LoKI-B papers), the factor $g_{ee}(u)$ is introduced,
		but not used consistently. In many places we find the expanded form
		$\frac{2\nu_{ee}u^{3/2}}{N\gamma}$ (e.g. in \cite[eqn. 39a-g]{Manual_2_2_0}).
		Using $g_{ee}$ instead simplifies the expressions considerably and makes clear
		that this product does not depend on the energy $u$.
\end{itemize}
The discrete form of the electron-electron operator is defined in the second half of
equation \cite[eqn. 38]{Manual_2_2_0} and is obtained as follows (see section
\ref{sec:dGdu-disc} for a related discussion):
\begin{equation}
	\left.-\frac{1}{N\gamma}\DERIV{G_{ee}(u)}{u}\right|_n
	\doteq
	-\frac{1}{N\gamma \Delta u}\left(G_{ee}(u_{\phalf{n}})-G_{ee}(u_{\mhalf{n}})\right).
\end{equation}
Also the fluxes are approximated using a central-difference scheme,
\begin{align}
	-\frac{1}{N\gamma}G_{ee}(u_{\phalf{n}})
		&= g_{ee}I(u_{\phalf{n}})\frac{f_{n+1}+f_{n}}{2}
		+ g_{ee}J(u_{\phalf{n}})\frac{f_{n+1}-f_{n}}{\Delta u}, \\
	-\frac{1}{N\gamma}G_{ee}(u_{\mhalf{n}})
		&= g_{ee}I(u_{\mhalf{n}})\frac{f_{n}+f_{n-1}}{2}
		+ g_{ee}J(u_{\mhalf{n}})\frac{f_{n}-f_{n-1}}{\Delta u}.
\end{align}
In order to write this in a more convenient form we define \cite[eqn. 39a--b]{Manual_2_2_0}
\begin{align}
	A_n &= -g_{ee}\frac{I(u_{\phalf{n}})}{2\Delta u} + g_{ee}\frac{J(u_{\phalf{n}})}{(\Delta u)^2}, \\
	B_n &= +g_{ee}\frac{I(u_{\mhalf{n}})}{2\Delta u} + g_{ee}\frac{J(u_{\mhalf{n}})}{(\Delta u)^2}.
\end{align}
Then
\begin{align}
	-\frac{1}{N\gamma}G_{ee}(u_{\phalf{n}})\frac{1}{\Delta u}
		&= B_{n+1}f_{n+1} - A_{n  }f_{n  }, \\
	-\frac{1}{N\gamma}G_{ee}(u_{\mhalf{n}})\frac{1}{\Delta u}
		&= B_{n  }f_{n  } - A_{n-1}f_{n-1}.
\end{align}
And for the electron-electron operator we find that
\begin{equation}
	\left.-\frac{1}{N\gamma}\DERIV{G_{ee}(u)}{u}\right|_n
	\doteq A_{n-1}f_{n-1} - (A_n+B_n)f_n + B_{n+1}f_{n+1}.
\end{equation}
Let us now look at the evaluation of the arrays $A_n$ and $B_n$. Firstly, from the definitions
of $I(u)$ and $J(u)$ we find that
\begin{align}
	I(u_{\phalf{n}})
		&= \int\limits_0^{u_{\phalf{n}}} f(u)\sqrt{u}\dd{u}
		\doteq
		\sum\limits_{i=0}^{n}f(u_i)\sqrt{u_i}\Delta u, \\
	J(u_{\phalf{n}})
		&= \frac{2}{3}\left(
			\int\limits_0^{u_{\phalf{n}}} f(u)u^{3/2}\dd{u}
			+
			u_{\phalf{n}}^{3/2}\int\limits_{u_{\phalf{n}}}^\infty f(u)\dd{u}
		\right)
		\nonumber \\
		&\doteq
		\frac{2}{3}\left(
			\sum\limits_{i=0}^{n}f(u_i)u_i^{3/2}\Delta u
			+
			u_{\phalf{n}}^{3/2}\sum\limits_{n+1}^\infty f(u_i)\Delta u
		\right)
\end{align}
These expressions can be written as
\begin{align}
	\bvec{A} &=\bmat{a}\bvec{f}, \\
	\bvec{B} &=\bmat{b}\bvec{f} \\
\end{align}
where the matrices $\bmat{a}$ and $\bmat{b}$ have typical elements
\begin{align}
	a_{ij} &= g_{ee}\begin{cases}
			-\frac{1}{2}\sqrt{u_j}          + \frac{2}{3}\frac{u_j^{3/2}}{\Delta u}	    & i \leq j \\
			\phantom{\frac{1}{2}\sqrt{u_j}} + \frac{2}{3}\frac{u_{\phalf{i}}^{3/2}}{\Delta u} & i > j.
		\end{cases}, \\
	b_{ij} &= g_{ee}\begin{cases}
			+\frac{1}{2}\sqrt{u_j}          + \frac{2}{3}\frac{u_j^{3/2}}{\Delta u}	    & i \leq j-1 \\
			\phantom{\frac{1}{2}\sqrt{u_j}} + \frac{2}{3}\frac{u_{\mhalf{i}}^{3/2}}{\Delta u} & i > j-1
		\end{cases}. \\
\end{align}
Three more modifications are made (only sketched in the manual). A reference to Rockwood \cite{Rockwood1973}
is provided for these steps:
TODO: fill in the details, these are not provided in the manual or LoKI-B paper. The details
and notation deviate from Rockwood's paper, which has most of them.
\begin{itemize}
    \item Energy conservation for a closed system with only electron-electron collisions is
	only respected numerically if $a_{ij}=b_{ji}$. The equivalents of these matrices in the
	text of Rokwood appear to be $A$ and $B$ (below eq. B7) and below B8 we see the statement
	$A=B^T$.
	\begin{enumerate}
		\item TODO: Check that $A$ and $B$ in Rockwood correspond to $a_{ij}$ and $b_{ij}$
		in LoKI-B. The expressions are written quite differently.
		\item Show that the continuous expression for the flux is consistent with
			this relation between $a$ and $b$; that the modification to use
			$a_{ji}$ instead of $b_{ij}$ is allowed within the accuracy of the
			discretization, that it does not change the physics.
	\end{enumerate}
    \item The flux boundary conditions $G(0)=G(u_{\mbox{{max}}})$ are imposed on the system.
	The manual states that this means that ``$g(x_{1/2})=g_{x_{{\cal N}+1/2}}=0$ and $A_0=A_{\cal N}=B_1=B_{{\cal N}+1}=0$'',
	where ${\cal N}$ is the number of cells.
	\begin{enumerate}
		\item How do these indices translate from MATLAB to C++? What is the meaning of index
			0 (of $A_0$) in MATLAB, which has 1-based arrays? That is not represented
			(does not exist). The MATLAB code (\SRC{ElectronKinetics.m} line 1991 has
			comment {\em ``because of power conservation, terms on the last row (cellNumber,:)
			and on the first column (:,1) are zero''}.
			NOTE: In Rockwood this change is given in equation B10.
	\end{enumerate}
    \item The requirement that $\dd{G_{ee}}/\dd{u}=0$ if $f$ is a Maxwellian distribution function
	is ensured by setting $a_{ij}=\sqrt{a_{ij}a_{j-1,i+1}}$.
	\begin{enumerate}
		\item I (JvD) did not find this expression in Rockwood's paper. This requirement is
			discused in appendix B of that paper (eq. 11), which is quite different,
			is says:
			\[
				A_{jk}n_jn_k = A_{k-1,j+1}n_{k-1}n_{j+1} = B_{j+1,k-1}n_{k-1}n_{j+1}
			\]
			(Here $n_j=n_e\sqrt{u_j}f_j$ and the distribution is Maxwellian.)
			Rockwood's explanation is clear (see the discussion leading to eq. B13),
			but he does not state {\em how} he achieves this condition.
			\begin{enumerate}
				\item TODO: Explain the expression and provide a reference.
					Also here: make clear that the modification is valid
					within the accuracy of the discretization and show
					that it does not change the physics.
					In particular the order of the application of the
					first and last modifications needs attention. In
					the expression above, $A_{ij}$ is changed,
					but since we assume $B=A^T$, we also change $B$
					this way.  A detailed explanation is needed.
			\end{enumerate}
	\end{enumerate}
\end{itemize}

\begin{framed}
Code observations:
\begin{itemize}
  \item In the MATLAB code, the name \SRC{alpha} is used for the factor
    $(n_e/N)e^2/(8\pi\epsilon_0^2)\ln\Lambda_D$, instead of \SRC{g_ee}
    (see \SRC{Boltzmann.m} line 1385 in version 2.2.0). The same constant appears
    a second time on line 2078, but this time the name \SRC{eeConstant} is used
    instead of \SRC{alpha}.)
    \begin{enumerate}
      \item In the C++ code, the variable \SRC{alpha} has been renamed to \SRC{g_ee}
        so the code matches the documentation.
      \item This also avoids confusion with Rockwood's constant $\alpha$,
        see appendix \ref{sec:RockwoodEE}, which is closely related to
        $g_{ee}$, but not identical.
    \end{enumerate}
  \item In the MATLAB code, the argument of the Coulomb logarithm is expanded as
    (NOTE: $T_e$ is in $\si{eV}$ in LoKI-B):
    \begin{equation}
      \Lambda_c
      = 12\pi\lambda_D^3n_e = 12\pi\left(\epsilon_0T_e/(n_ee)\right)^{3/2}n_e
      = 12\pi\left(\epsilon_0 T_e/e\right)^{3/2}n_e^{-1/2}.
    \end{equation}
    In the C++ code, the readability of these expressions has been improved by
    introducing \SRC{lambdaD} as an intermediate variable and using the first
    expression for $\Lambda_c$.
\end{itemize}
\end{framed}

\section{Discretization}
\label{sec:discretization}

\subsection{Final form of the equation}
In \cite[eqn. 3a]{Tejero2019} the final form of the two-term approximation of the
Boltzmann equation with a temporal growth term is written as
\begin{equation}
  \frac{1}{N\gamma}\MEAN{\nu_{\mbox{eff}}}uf(u) + \frac{1}{N\gamma}\DERIV{G(u)}{u} = S(u).
\end{equation}
The equation with the spatial growth model is similar, only the first term takes
a different form. The equation is subject to the normalization condition
\begin{equation}
  \int\limits_0^\infty \sqrt{u}f(u)du=1.
  \label{eq:f-norm}
\end{equation}
Bringing all terms of the EBE to the right-hand side of the equation yields
\begin{equation}
  -\frac{1}{N\gamma}\MEAN{\nu_{\mbox{eff}}}uf(u) - \frac{1}{N\gamma}\DERIV{G(u)}{u} + S(u) = 0.
  \label{eq:EBE-temp}
\end{equation}
In LoKI-B, this particular form of the equation is cast in matrix-vector form,
\begin{equation}
  \sum\limits_{j=0}^{N_c-1}C_{ij}f_j = 0.
  \label{eq:Cf=0}
\end{equation}
In this equation, the system matrix $C_{ij}=\sum_x C_{x,ij}$, where each
matrix $C_{x,ij}$ corresponds to one of a terms, identified by $x$, in
equation \eqref{eq:EBE-temp}. Then, for example
\[
   \sum\limits_{j=0}^{N_c-1}C_{el,ij}f_j
   \doteq
   -\frac{1}{N\gamma}\left.\DERIV{G_{el}(u)}{u}\right|_{u_i}.
\]
Note that a constant multiplication factor could still be applied to the matrix
$C_{ij}$ in equation \eqref{eq:Cf=0} without changing the solution, but that
would change the physical meaning of an expression like $\sum_jC_{el,ij}f_j$.
Note that for some terms the coefficients depend on $f$, making this a
{\em non-linear system}.

TODO: verify that the above is indeed what is done by LoKI-B (and be very precise).

Since the system is homogeneous, the solution is determined up to a constant
multiplication factor. This follows from the normalization condition
\eqref{eq:f-norm}, which can be approximated as
\begin{equation}
  \sum\limits_{j=0}^{N_c-1} \sqrt{u_j} f_j \Delta u = 1.
  \label{eq:f-norm-disc}
\end{equation}
This condition can be imposed ion the system in multiple ways:
\begin{itemize}
  \item Replace equation \eqref{eq:Cf=0} with the discrete form of the
    normalization condition as given by \eqref{eq:f-norm-disc}.
  \item Replace this equation with the equation $f_0=1$ (or another fixed
    number), solve the system and scale the solution afterwards.
\end{itemize}
It appears that at present both are done (in both MATLAB and C++ versions). The
advantage of (only) using the second mathod is that no unnecessary non-zero
entries are introduced in the system matrix. This is beneficial when a sparse
matrix solver is adopted. Especially when a band matrix format is used, it
prevents all upper diagonals to be allocated, in most cases only containing
a single non-zero element due to the normalization condition.

\subsection{Discretization of the Energy Transport Terms}
\label{sec:dGdu-disc}

The LoKI-B paper \cite{Tejero2019} discusses the numerical recipes in
section 3.4. There it is stated that the finite-difference method of
Rockwood \cite[appendix A]{Rockwood1973} is used. The relation between Rockwood's
discretization strategy and the one adopted in LoKI-B is not immediately
clear, since Rockwood provides explicit expression for the two terms
he considers (field and elastic terms), not the general recipe.

Rockwood approximates $\dd{G(u)}/\dd{u}$ in the cell points $k$ as
\begin{equation}
  \left.\DERIV{G_x(u)}{u}\right|_k
  = \frac{G_x(u_{\phalf{k}}) - G_x(u_{\mhalf{k}})}{\Delta u}.
\end{equation}
It is important to realize that this amounts to a finite-{\em volume} method,
since the right-hand side can also be written as
\[
  \frac{1}{\Delta u}\left[G_x(u_{\phalf{k}}) - G_x(u_{\mhalf{k}})\right]
  =
  \frac{1}{\Delta u}\int\limits_{u_{\mhalf{k}}}^{u_{\phalf{k}}}\DERIV{G_x(u)}{u}\dd{u},
\]
which makes clear that the approximation amounts to replacing the value of
$\dd G_x/\dd u$ with its mean value in the interval
$[u_{\mhalf{k}},u_{\phalf{k}}]$. Except for the factor $1/\Delta u$ this is,
of course, the volume integral of $\dd G_x(u)/\dd u$ over that interval.
All this can be recognized as applying Gau\ss' theorem to an integral over
a one-dimensional energy volume, with flux $G(u)$ and flux-divergence
$\dd G(u)/\dd u$.

This analysis makes clear that the emphasis can be placed on a proper discretization
of the flux $G(u)$ on the boundaries $u_\mhalf{k}$ and $u_\phalf{k}$ of the cell
around $u_k$. LoKI-B follows Rockwood in adopting a central difference scheme for
the approximation of equation \eqref{eq:G(g)}. Using the definition of $G_x(u)$
that appears in the user manual, see equation \ref{eq:G(g)} of the present text,
we get
\begin{align}
  \frac{1}{N\gamma}G_x(u_{\phalf{k}})
    &\doteq g_x(u_{\phalf{k}})\left(\frac{f(u_{k+1})+f(u_k)}{2}+c_x\frac{f(u_{k+1})-f(u_k)}{\Delta u}\right) \nonumber \\
    &\doteq
      -g_x(u_{\phalf{k}})\left(\frac{c_x}{\Delta u}-\frac{1}{2}\right)f(u_k)
      +
      g_x(u_{\phalf{k}})\left(\frac{c_x}{\Delta u}+\frac{1}{2}\right)f(u_{k+1})
  \\
  \frac{1}{N\gamma}G_x(u_{\mhalf{k}})
    &\doteq g_x(u_{\mhalf{k}})\left(\frac{f(u_{k})+f(u_{k-1})}{2}+c_x\frac{f(u_{k})-f(u_{k-1})}{\Delta u}\right) \nonumber \\
    &\doteq
      g_x(u_{\mhalf{k}})\left(\frac{c_x}{\Delta u}+\frac{1}{2}\right)f(u_k)
      -
      g_x(u_{\mhalf{k}})\left(\frac{c_x}{\Delta u}-\frac{1}{2}\right)f(u_{k-1})
\end{align}
Which results in the following discrete result,
\begin{align}
  \frac{1}{N\gamma}\DERIV{G_x(u)}{u}
  =& \frac{1}{N\gamma}\frac{G_x(u_{\phalf{k}}) - G_x(u_{\mhalf{k}})}{\Delta u} \nonumber \\
       =& +\left[\frac{g_x(u_{\mhalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}-\frac{1}{2}\right)\right]f(u_{k-1}) \nonumber \\
        & -\left[
              \frac{g_x(u_{\mhalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}+\frac{1}{2}\right)
            + \frac{g_x(u_{\phalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}-\frac{1}{2}\right)
           \right] f(u_k) \nonumber \\
        & +\left[\frac{g_x(u_{\phalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}+\frac{1}{2}\right)\right]f(u_{k+1}) \nonumber \\
       =& M(k,k-1)f(u_{k-1}) + M(k,k)f(u_k) + M(k,k+1)f(u_{k+1}).
\end{align}
NOTE: A relation between the central coefficient $M(k,k)$ and the neighbour
coefficients can be derived as follows:
\begin{align}
  -M(k,k)
    &=
    \frac{g_x(u_{\mhalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}+\frac{1}{2}\right)
    +
    \frac{g_x(u_{\phalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}-\frac{1}{2}\right) \nonumber \\
    &=
    \frac{g_x(u_{\mhalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}-\frac{1}{2}\right)
    +
    \frac{g_x(u_{\phalf{k}})}{\Delta u}\left(\frac{c_x}{\Delta u}+\frac{1}{2}\right)
    + \frac{g_x(u_{\mhalf{k}})}{\Delta u} - \frac{g_x(u_{\phalf{k}})}{\Delta u} \nonumber \\
    &=
    M(k,k-1)
    +
    M(k,k+1)
    + \frac{g_x(u_{\mhalf{k}}) - g_x(u_{\phalf{k}})}{\Delta u}.
\end{align}
this can be used later on to do some stability analysis on the scheme. In brief:
consider a situation where this is the only term in the Boltzmann equation, and
assume that $g_x(u_{\mhalf{k}})=g_x(u_{\phalf{k}})$ for some cell $k$. Then we can
derive
\begin{align}
  &M(k,k-1)f(u_{k-1}) + M(k,k)f(u_k) + M(k,k+1)f(u_{k+1}) = 0 \nonumber \\
  \implies & M(k,k)f(u_k) = - M(k,k+1)f(u_{k+1}) - M(k,k-1)f(u_{k-1}) \nonumber \\
  \implies & (M(k,k-1)+M(k,k+1))f(u_k) = + M(k,k+1)f(u_{k+1}) + M(k,k-1)f(u_{k-1}) \nonumber \\
  \implies & f(u_k) = (1-\alpha)f(u_{k+1}) + \alpha f(u_{k-1}),
\end{align}
where $\alpha=M(k,k-1)/(M(k,k-1)+M(k,k+1))$. Only if the coefficients $M(k,k-1)$
and $M(k,k+1)$ have the same sign will this result in monotonic behaviour of the solution
$f(u)$. From this we can deduce the requirement that $||c_x/\Delta u||>1/2$, or
$||\Delta u/c_x||<2$. This number can be recognized as the {\em grid P\'eclet number}
of the problem. The condition can be eliminated by using another scheme than the
central difference scheme (upwind, Scharfetter-Gummel, ...).

Note that a true finite-difference scheme (not in LoKI-B) would have been obtained by
first employing the product rule for differentiation and grouping terms with the
same derivative of $f(u)$,
\begin{equation}
  \frac{1}{N\gamma}G_x(u)
    = \DERIV{g_x(u)}{u}f(u)
    + \left(g_x(u)+\DERIV{g_x(u)}{u}c_x\right)\DERIV{f(u)}{u}
    + g_x(u)c_x\DDERIV{f(u)}{u},
\end{equation}
then use $f'(u_k)\doteq(f(u_{k+1})-f(u_{k-1}))/(2\Delta u)$ and
$f''(u_k)\doteq(f(u_{k+1})+f(u_{k-1})-2f(u_k))/(\Delta u)^2$, etc.

\subsection{Power Terms}
\label{sec:power-terms}

In the code some integrals appear in a form that differs from that in the LoKI-B
paper and manual. As an example, consider the energy gain and loss terms for CAR
gases (see \cite[eqn 24a--h]{Tejero2019} and \cite[eqn 28a--h]{Manual_1_0_0}),
\begin{equation}
	\frac{\Theta^{gain}_{x=el,CAR}}{N} = -\int\limits_0^\infty g_x(u)c\DERIV{f(u)}{u}\dd{u}
\end{equation}
\begin{equation}
	\frac{\Theta^{loss}_{x=el,CAR}}{N} = -\int\limits_0^\infty g_x(u)f(u)\dd{u}
\end{equation}
Partial integration of the expression for the gain yields
\begin{equation}
	\frac{\Theta^{gain}_{x=el,CAR}}{N}
	=
	-\left.g_x(u)f(u)\right|_0^\infty
	+\int\limits_0^\infty \DERIV{g_x(u)}{u}cf(u)\dd{u}
	=
	\int\limits_0^\infty \DERIV{g_x(u)}{u}cf(u)\dd{u},
\end{equation}
where the fact that $g_x(u)$ vanishes for $u=0$ and the product $g_x(u)f(u)$ vanishes
for $u\rightarrow\infty$. The resulting term can be approximated as
\begin{equation}
	\frac{\Theta^{gain}_{x=el,CAR}}{N}
	\doteq
	\sum_{i=0}^{N_c-1} \frac{g_x(u_{i+1/2})-g_x(u_{i-1/2})}{\Delta u}cf(u_i)\Delta{u}
	=
	\sum_{i=0}^{N_c-1} \left[g_x(u_{i+1/2})-g_x(u_{i-1/2})\right]cf(u_i).
\end{equation}
The loss term can be approximated as
\begin{equation}
	\frac{\Theta^{loss}_{x=el,CAR}}{N}
	\doteq
	\sum_{i=0}^{N_c-1} \frac{g_x(u_{i+1/2})+g_x(u_{i-1/2})}{2}f(u_i)\Delta{u}
	=
	\sum_{i=0}^{N_c-1} \left[g_x(u_{i+1/2})+g_x(u_{i-1/2})\right]\frac{\Delta u}{2}f(u_i).
\end{equation}
The net power is obtained by adding the gain and loss terms and results in
the approximation
\begin{equation}
	\frac{\Theta^{gain}_{x=el,CAR}}{N}
	\doteq
	\sum_{i=0}^{N_c-1} \left[\left(c+\frac{\Delta u}{2}\right)g_x(u_{i+1/2})-\left(c-\frac{\Delta u}{2}\right)g_x(u_{i-1/2})\right]f(u_i).
\end{equation}
These approximate expressions for the gain and net power have been implemented in
the code, except that in the code also an additional factor $\gamma$ appears (see
sections \eqref{sec:G_x,g_x} and \eqref{sec:gamma-constant}).
In the code the parenthesized coefficients are called \SRC{auxHigh} and \SRC{auxLow}.



\section{Matrices \& Vectors}

\subsection{Calculating the Maximum Relative Difference of Two Vectors}

During the development of the C++ code, a nasty difference between MATLAB
and C++ was discovered in the handling of NaN (not-a-number values) values,
that are produced by such operations as $0.0/0.0$, $\infty\cdot 0.0$ and
$\infty/\infty$, where $\infty$ indicates the platform's \SRC{inf} value.

When looking for the maximum element of an array, MATLAB skips NaN's and
returns the highes non-NaN element.
\begin{lstlisting}[language=matlab]
>> max(abs([0 0]./[1 0]))
ans =
     0
\end{lstlisting}
On the other hand, C++ with Eigen returns NaN. The last line of the code
below shows the calculation that was previously in the C++ version of LoKI-B,
it prints a NaN:
\begin{lstlisting}[language=matlab]
    #include <eigen3/Eigen/Dense>
    ...
    using Vector = Eigen::VectorXd;
    Vector ev1(2); ev1[0] = 0.; ev1[0] = 0.;
    Vector ev2(2); ev2[0] = 1.; ev2[0] = 0.;
    std::cout << (ev1.array()/ev2.array()).cwiseAbs().maxCoeff() << std::endl;
\end{lstlisting}
For this reason, a member \SRC{maxRelDiff} has been introduced. That avoids
the spurious NaN's by skipping over points for which both values (old and new)
are different. NOTE that this implements the relative {\em difference}, using
the averaged absolute values as reference, rather than the olf or new one.

\subsection{Linear Systems, Matrix Inversion}

Eigen, the various Hessenberg-solvers.

\subsection{The Smart Grid}

\subsubsection{Calculation of the Dynamic Range of the EEDF}

The smart grid functionality can be used to let the program adjust the
upper boundary of the energy grid such that the dynamic range of the
EEDF is within a user-specified specific range. The number of decades
that the EEDF drops is given by the expression
\begin{equation}
    N_d = \log_{10} f_{\mbox{max}} - \log_{10} f_{\mbox{min}}.
\end{equation}
LoKI-B assumes that the highest and lowest EEDF values are attained on
the first and last energy grid point, respectively. This is the expression
that is also implemented in the MATLAB version of LoKI-B. In case of
an underflow for high energy values, such that $f_{\mbox{min}}=0$, while
$f_{\mbox{max}}$ is finite, MATLAB produces the value \SRC{Inf}, since
\SRC{log10} is specified to return \SRC{-Inf} for zero-valued arguments\footnote{
See: \url{https://nl.mathworks.com/help/matlab/ref/log10.html}}.
In such case, a test like \SRC{Inf > N_max} will evaluate as \SRC{true}
and this tells LoKI-B to reduce the upper boundary of the energy grid.
Also the C/C++ function \SRC{log10} is specified to return \SRC{-Inf}
for zero-valued arguments.

It is tempting to combine the logarithms in this expression, wich would
result in
\begin{equation}
    N_d= \log_{10} \frac{f_{\mbox{max}}}{f_{\mbox{min}}}.
\end{equation}
It is important to realize that these expressions may give different
results in the case of underflow, when {\em signed} zeros are produced:
the IEE754 floating point standard recognizes \SRC{0.0} and the
signed zero \SRC{-0.0} as separate numbers, although they do compare
equal\footnote{See: \url{https://en.wikipedia.org/wiki/Signed_zero}}.
However, for a positive finite number $f$ we have \SRC{f/(+0.0)=+Inf}
and \SRC{f/(-0.0)=-Inf}, and while \SRC{log10(+Inf)=+Inf}, we have
\SRC{log10(-Inf)=NaN}. This means that for a positive $f_{\mbox{max}}$ we get
\begin{equation}
    \log_{10} f_{\mbox{max}} - \log_{10}(\pm 0.0)
  = \log_{10} f_{\mbox{max}} - (-\SRC{Inf}) = \SRC{+Inf}.
\end{equation}
whereas
\begin{equation}
  \log_{10} (f_{\mbox{max}}/(\pm 0.0)) = \log_{10}(\pm\SRC{Inf}),
\end{equation}
which gives \SRC{NaN} instead of \SRC{Inf} for a signed zero.

In the C++ code we have implemented the function \SRC{calcDecades(v1,v2)}
for this calculation. It has been implemented to return
\SRC{log10(abs(v1/v2)}. Taking the absolute value allows the calculation
to rely on only one calculation of a logithm, while avoiding the problem
that a \SRC{NaN} is produced for signed zeros. It also allows a comparison
of the size of scalars that are both negative or have different signs.
Perhaps most importantly, it centralizes this simply but tricky bit of
code, so it does not have to be repeated three times in the code.

\subsection{A Bisecting Smart Grid Implementation}

Let $[D_m,D_p]$ denote the user-specified dynamic range of the EEDF,
and $D(u_x)$ be the dynamic range that is realized for an upper
energy that is equal to $u_x$. The `smart grid feature' can be used
to adjust $u_{\mbox{max}}$ such that $D(u_{\mbox{max}})\in[D_m,D_p]$.
The original implementation uses an adjustment with a user-specified
factor, first lowering $u_{\mbox{max}}$ until the lower boundary is
respected, then increasing $u_{\mbox{max}}$ until the upper boundary
is respected. This can be a slow process, and there is no guarantee
that the criteria are actually met after the algorithm is finished:
when the adjustment factor is too high, you may go from too low to
too high in a single step. On the other hand, choosing a small
adjustment factor will result in lots of iterations.

For these reasons, an alternative implementation of the smart grid adjustment
has been implemented in the C++ version of the code. The new algorithm consists
of two parts. Firstly, values $u_m$ and $u_p$ are determined such that
$[D(u_m),D(u_p)]$ has overlap with $[D_m,D_p]$. (The latter interval
may be enclused entirely by the former, or the overlap may be partial).
Secondly, the interval $[u_m,u_P]$ is bisected until $[D(u_m),D(u_p)]$
is fully within the specified range and the final $u_{\mbox{max}}$ is
chosen from $[u_m,u_P]$. In detail:
\begin{enumerate}
  \item Set $u_m=u_p=u_{\mbox{max}}$, solve the EEDF and calculate $D(u_M)$;
	if that is in the required range, we are ready.
  \item If $D(u_p)$ is below the required range, keep doubling $u_p$,
	setting $u_{\mbox{max}}=u_p$,
	solving the EEDF and calculating $D(u_p)$ unless it is in the
	required range or above. Else:
        If $D(u_m)$ is above the required range, keep halving $u_m$,
	setting $u_{\mbox{max}}=u_m$,
	solving the EEDF and calculating $D(u_m)$ unless it is in the
	required range or below.
  \item Until $D(u_{\mbox{max}})$ is in the specified range,
	set $u_{\mbox{max}}=(u_m+u_p)/2$, solve the EEDF and calculate
	$D(u_{\mbox{max}})$. If $D(u_{\mbox{max}})<D_m$,
	set $u_m=u_{\mbox{max}}$, else if $D(u_{\mbox{max}})>D_p$,
	set $u_p=u_{\mbox{max}}$. (This bisects the interval until
	one of its end points matches the criterium.)
\end{enumerate}
\begin{framed}
At present, the new implementation can be enabled only by
commenting in the macro \SRC{LOKIB_USE_BISECTING_SMART_GRID}
in \SRC{source/ElectronKinetics.cpp} and recompiling. This
must be controllable from the input file instead.
\end{framed}

\section{Build System}

\subsection{cmake}

\subsection{autotools}

\subsection{Cross Compilation}

\subsection{Automated Testing}

Unit tests, checking results with reference data, comparing the MATLAB and C++
versions, comparisons with BOLSIG+ output.

\appendix

\section{More on the Electron-Electron Operator}

\label{sec:RockwoodEE}

\subsection{Rockwood's Presentation}

Rockwood's paper \cite{Rockwood1973} considers a distribution function $n(\epsilon,t)$ which
is defined such that $n(\epsilon,t)\dd{\epsilon}$ is the number of electrons in the energy
interval $\dd{\epsilon}$.
The rate of change of $n$ for
a system with only electron collisions takes the form (eq. B5)
\begin{equation}
	\PDEV{n}{t} = -\PDEV{J_{ee}}{\epsilon},
	\label{rockwood:dn/dt-ee}
\end{equation}
where the flux in energy space is given by
\begin{equation}
	J_{ee}
	= \alpha\left[P\left(\frac{n}{2\epsilon}-\PDEV{n}{\epsilon}\right) + Qn\right].
	\label{rockwood:J_ee}
\end{equation}
The functions $P(\epsilon,t)$ and $Q(\epsilon,t)$ are defined below eq. B5 and read
\begin{align}
  P(\epsilon,t) &= 2\epsilon^{-1/2}\int\limits_0^\epsilon xn(x,t)\dd{x} + 2\epsilon\int\limits_\epsilon^\infty x^{-1/2}n(x,t)\dd{x}, \\
  Q(\epsilon,t) &= 3\epsilon^{-1/2}\int\limits_0^\epsilon  n(x,t)\dd{x}.
\end{align}
and $\alpha$ is given below equation B1,
\begin{equation}
	\alpha = \frac{2}{3}\pi e_G^4\sqrt{\frac{2}{m_e}}\ln\Lambda_D.
\end{equation}
Here we have added the suffix $G$ to $e$ to emphasize that the charge is expressed in
Gau\ss ian units. A translation to the SI unit system is achieved by the
substitution\footnote{See for example \url{https://en.wikipedia.org/wiki/Gaussian_units}.}
$e_G = e/\sqrt{4\pi\epsilon}$, which results in
\begin{equation}
	\alpha
	= \frac{2}{3}\pi \left(\frac{e}{\sqrt{4\pi\epsilon_0}}\right)^4\sqrt{\frac{2}{m_e}}\ln\Lambda_D
	= \frac{1}{24}\frac{e^4}{\pi\epsilon_0^2}\sqrt{\frac{2}{m_e}}\ln\Lambda_D.
\end{equation}
The function $n(\epsilon,t)$ is related to the distribution function $f_\epsilon(\epsilon,t)$ that
is used in LoKI-B by the relation
\begin{equation}
	n(\epsilon,t) = n_e(t)\sqrt{\epsilon}f_\epsilon(\epsilon,t)
	\label{eqn:n-rockwood}
\end{equation}
Substitution of \eqref{eqn:n-rockwood} in the expressions for $P$, $Q$ gives
\begin{align}
  P(\epsilon,t)
	&= \frac{3n_e}{\sqrt{\epsilon}}\frac{2}{3}\left(\int\limits_0^\epsilon x^{3/2}f_\epsilon(x,t)\dd{x} + \epsilon^{3/2}\int\limits_\epsilon^\infty f_\epsilon(x,t)\dd{x}\right)
	= \frac{3n_e}{\sqrt{\epsilon}}J(\epsilon,t), \\
  Q(\epsilon,t)
	&= \frac{3n_e}{\sqrt{\epsilon}}\int\limits_0^\epsilon  \sqrt{x}f_\epsilon(x,t)\dd{x}
	= \frac{3n_e}{\sqrt{\epsilon}}I(\epsilon,t),
\end{align}
where we have used the definitions of the functions $I$ and $J$ from equations \eqref{eq:I} and \eqref{eq:J}.
Finally, substitution of these results in the equations for $J_{ee}$ and the evolution of $n$, yields
\begin{align}
  J_{ee} &= 3\alpha n_e^2\left[-I(\epsilon)f_\epsilon - J(\epsilon)\PDEV{f_\epsilon}{\epsilon}\right], \\
  \sqrt{\epsilon}\PDEV{n_ef_\epsilon}{t} &= -\PDEV{J_{ee}}{\epsilon}.
\end{align}
Note that $n_e$ could be taken outside of the time-derivative: it is constant, since
we have assumed that only (elastic) electron collisions can happen.

The last step is to cater to LoKI's usage of $\si{eV}$ as unit. To this end we
use $\epsilon = u(\epsilon)e$ and $f_\epsilon(\epsilon)\sqrt{\epsilon}\dd{\epsilon}$,
from which it follows that $f_u(u)\sqrt{u}\dd{u} \implies f_\epsilon(\epsilon) = f_u(u)e^{-3/2}$.
Furthermore, $I(u)=I(\epsilon)$ and $J(u)=J(\epsilon)/e$. Substitution yields the
equations using LoKI-B quantities (in $\si{eV}$),
\begin{align}
  J_{ee}(u) &= 3\alpha n_e^2 e^{-3/2}\left[-I(u)f_\epsilon - J(u)\PDEV{f_u}{u}\right], \\
  \PDEV{f_u}{t} &= -\frac{1}{n_e\sqrt{u}}\PDEV{J_{ee}}{u},
\end{align}
The first expression leads us to the introduction of
\[
	\alpha_{eV}
	:= e^{-3/2}\alpha
	= \frac{1}{24}\frac{e^2}{\pi\epsilon_0^2}\sqrt{\frac{2e}{m_e}}\ln\Lambda_D
	= \frac{1}{24}\frac{e^2}{\pi\epsilon_0^2}\gamma\ln\Lambda_D.
\]
This constant corresponds to Hagelaar's $a$ \cite[eq. 37]{Hagelaar2005}. In that paper
on BOLSIG+ \cite[eq. 32-37]{Hagelaar2005}, the original Rosenbluth form
\cite[eq. B1--3]{Rockwood1973} of the equations is used (these are not in divergence-flux
form).

In order to identify the relation of the function $J_{ee}$ with the function $G_{ee}$
that is used in LoKI-B, we expand the time-derivative of $\sqrt{n_ef(u)}$ and
divide by $N\gamma$,
\begin{equation}
	\frac{1}{N\gamma}\sqrt{u}\PDEV{f}{t} + \frac{1}{N\gamma}\sqrt{u}f\frac{1}{n_e}\PDEV{n_e}{t} + \frac{1}{N\gamma}\PDEV{J_{ee}/n_e}{u} = 0.
\end{equation}
This is the form that is compatible with e.g. \cite[eq, 3a]{Tejero2021}.
Comparison yields
\begin{equation}
	\frac{1}{N\gamma}\PDEV{G_{ee}}{u}
	= \PDEV{}{u}\left(3\alpha_{eV}\frac{n_e}{N}\left[-I(u)f_\epsilon - J(u)\PDEV{f_u}{u}\right]\right)
	= -\PDEV{}{u}\left(g_{ee}\left[I(u)f_\epsilon + J(u)\PDEV{f_u}{u}\right]\right),
\end{equation}
which indeed gives our equation \eqref{eq:-1/NgammadGee/du}.


\subsection{Transformation of the Electron-Electron Operator}

WARNING: this section is a sketch and may be full of mistakes.
For a lazy afternoon: check if it is useful to use the fact that
\begin{equation}
	\int\limits_0^u f(u')(u')^{k+\frachalf}\dd{u'}
	=
	\int\limits_0^\infty f(u')(u')^{k+\frachalf}\dd{u'}
	-
	\int\limits_u^\infty f(u')(u')^{k+\frachalf}\dd{u'}
	=
	<u^k>
	-
	\int\limits_u^\infty f(u')(u')^{k+\frachalf}\dd{u'}
\end{equation}
When applied to the first term of $J(u)$ this gives
\begin{equation}
	J(u)
	= \frac{2}{3}\left(
		<u>
		-
		\int\limits_u^\infty f(u')(u')^{3/2}\dd{u'}
		+
		u^{3/2}\int\limits_u^\infty f(u')\dd{u'}
	\right)
	= \frac{2}{3}\left(
		<u>
		-
		\int\limits_u^\infty f(u')((u')^{3/2}-u^{3/2})\dd{u'}
	\right),
\end{equation}
and note that the mean energy $<u>$ is available at the point of evaluation, where
it is needed to calculate $T_e$, which is needed to calculate the Debye length.

When applied to $I(u)$, the transformation yields
\begin{align}
	I(u) = 1 - \int\limits_u^\infty f(u')\sqrt{u'}\dd{u'}.
\end{align}
Substitution of the new expressions for $I(u)$ and $J(u)$ in the expressions for $A_n$
and $B_n$ yields an integral that does not cover the entire energy grid,
\begin{align}
	A_n &= -\frac{g_{ee}}{\Delta u}\left(\frac{I(u_{\phalf{n}})}{2} - \frac{J(u_{\phalf{n}})}{\Delta u}\right)
		\nonumber \\
	&= -\frac{g_{ee}}{\Delta u}\left(
		\frac{1}{2} - \frac{2}{3}\frac{<u>}{\Delta u}
		+ \frac{1}{\Delta u}\int\limits_{u_{\phalf{n}}}^\infty f(u')\left(-\frac{\sqrt{u'}}{2} + \frac{2}{3\Delta u}((u')^{3/2}-u_{\phalf{n}}^{3/2})\right)\dd{u'}
		\right),
		\\
	B_n &= +\frac{g_{ee}}{\Delta u}\left(\frac{I(u_{\mhalf{n}})}{2} + \frac{J(u_{\mhalf{n}})}{\Delta u}\right)
		\nonumber \\
	&= +\frac{g_{ee}}{\Delta u}\left(
		\frac{1}{2} + \frac{2}{3}\frac{<u>}{\Delta u}
		+ \frac{1}{\Delta u}\int\limits_{u_{\mhalf{n}}}^\infty f(u')\left(-\frac{\sqrt{u'}}{2} - \frac{2}{3\Delta u}((u')^{3/2}-u_{\mhalf{n}}^{3/2})\right)\dd{u'}
		\right).
\end{align}

\bibliography{../../doc/reflist}

\end{document}
